---
title: "Regex Explained"
output: html_document
---

A (very) important part of natural language processing is searching for patterns of characters. While this may seem like a somewhat boring part of the process, it is usually the first task in cleaning and preparing data for natural language processing. 

In this tutorial, we will go through how regex is used in R and specifically in the `tidyverse` via the `stringr` package. 

## Pattern Matching with Stringr

`stringr` is the tidyverse solution to working with strings.

### Functions that return a vector

Some stringr functions will return a single vector, which can be turned into a variable using a `mutate` function from the `dplyr` package. In my opinion, these are the most useful functions in `stringr`. They do things like return if a pattern exists, return a pattern itself, or replace a pattern with something new.  

* `str_detect(string, pattern)` detects the presence or absence of a pattern in a string. It will return a TRUE FALSE based on if that pattern is found.
* `str_extract(string, pattern)` extracts text corresponding to the matched pattern
* `str_replace(string, pattern, replacement)` replaces a matched pattern and returns a character vector.

**These functions all have a variant with an `_all` suffix, which will match all occurrences of a pattern in a string. Without this only the first pattern will be matched**

Lets see how these functions compare when working with data. First we will create a data.frame with a text variable with some sample text.

```{r}
sample = data.frame(text = c("this is some sample text",
                    "it is comprised of ample text",
                    "I hope it will help",
                    "if not, than 'oh welp.'",
                    "if just text than we are in heaven,",
                    "but life is hard so 567."
                    ))

kable(sample)%>%
  kable_styling("striped")
```

Now lets test out `str_detect`, `str_extract`, and `str_replace` with a pattern of "if".

```{r}

sample%>%
  mutate(detect = str_detect(text, "if"),
         extract = str_extract(text, "if"),
         replace = str_replace(text, "if", "IF"))%>%
  kable()%>%
  kable_styling("striped")

```


You will notice that each one of these operations matched the "if" in "life". When we get deeper into the regex portion of this lesson, we will go over how to correct for this. 

### The _all suffix

We mentioned earlier that by appending `_all` we will match all instances of the patterns. Let's take a look at what that means in pratice. 

```{r}
all = c("I am repetitive and repetitive")

str_extract_all(all, "repetitive")
```

Unfortunately, this returns a list of the extracted patterns, so it will be a little difficult to work with this inside a dataframe. This is because you are returning multiple things into what in a dataframe would be a single observation. In other words, the string you are inputting into the function has a length of one, but the number of patterns you can return, in this case two, will oftentimes be greater than one. Thus the function returns a list.  

However, if you are looking to replace all matched patterns within a string, what you return will just be the edited string. And thus, `str_replace_all()` will be tidyverse compatible.  

```{r}
all = c("I am repetitive and repetitive")

str_replace_all(all, "repetitive", "very repetitive")
```

### Functions that retrun a list of vectors

Sometimes you will need multiple variables to express the result of a function. In `stringr` this occurs when you are finding the starting and ending position of a pattern or splitting a string into two different variables. You won't use `mutate` when working with these functions in a tidy manner. 

* `str_locate(string, pattern)` finds (or locates) the first position of a pattern and returns a matrix with a start and end
* `str_split(string, pattern)`

```{r}

text = c("oranges and apples",
             "pineapple and ananas")

str_split_fixed(text, " and ", n = 2)
```

## Metacharacters in Regex

So we have gone over how the three main functions of stringr works with basic patterns. The power of regex comes from using special characters or combinations of characters to mean something different than their literal meaning. For example, a period `.` typically signifies the end of a sentence, but in regex, it serves as a stand in for any character. 

Let's see go over a bunch of these special characters in regex. Look at the comment for how the metacharacter works.

```{r}

sample%>%
  mutate(period = str_extract(text, "."), # . stands for anything. It will return the first character
         character = str_extract(text, "\\w"), # \\w stands for any character
         digit = str_extract(text, "\\d"), # \\d stands for any digit
         white_space = str_extract(text, "\\s")) # \\ stands for any whitespace
  
  

```

Moving forward, we will refer to characters that only retain their literal meaning as literals. 

### Escaping Special Characters

This naturally leads to the question of how do you match a period. You use the escape character which is a backward slash `\`. This will tell regex to interpret the next character as a "literal". In R, you have to double escape or write: `\\`.

```{r warning=FALSE, message=FALSE}
# if the word flutter wasn't in here 
sample%>%
  mutate(detect = str_detect(text, "\\."),
         extract = str_extract(text, "\\."),
         replace = str_replace(text, "\\.", "REPLACE"))%>%
  kable()%>%
  kable_styling("striped")


```

## Conditional and Optional Patterns

First lets create our data.

```{r warning=FALSE, message = FALSE}

text = data.frame(
  characters = c("can", "man", "fan", "ran", "tan")
)

```

Now lets match just can, man, and fan on this set. We can use the `[]` to match specific characters. Think of it like an OR statement. `[abc]` will be a, b or c. So how could we apply this to match just can, man, and fan? 

```{r warning=FALSE, message=FALSE}
# if the word flutter wasn't in here 
text%>%
  mutate(match = str_extract(characters, "[cmf]an"))

```

What about characters that we don't want included? While there are only three characters that we would place inside our square brackets this time, what if we wanted to include all characters except just one or two? We would use the `^` operator then. Just put it at the beginning of your square brackets!

```{r warning=FALSE, message=FALSE}
# if the word flutter wasn't in here 
text%>%
  mutate(match = str_match(characters, "[^rt]an"))

```

This leads to the obvious question, what if we had a long list of characters we wanted to exclude or include? What would be the short hand for that? We can use the `-` operator to find characters between two characters. In my opinion this works best for numbers, but lets see how this would work on our previous dataset just pulling back characters that have a first letter between "e" and "s".

```{r warning=FALSE, message=FALSE}
# if the word flutter wasn't in here 
text%>%
  mutate(match = str_match(characters, "[e-r]an"))

```

In the above cases, we knew that we wanted at least one of the characters. What about when a pattern is completely optional. For example, can we make a regex that pulls back both "successful" and unsuccessful"? 

No we cannot, it is beyond science. 

Of course, this is not the case. We can use the `?` operator. Putting a `?` after a character will make that character optional in the pattern. For example:

```{r warning=FALSE, message=FALSE}
# if the word flutter wasn't in here 

str_match(c("successful", "unsuccessful", "failure"), "u?n?successful")%>%
  kable()

```

As you can see, the regex pulled back successful and unsuccessful but not failure because the "un" was optional due to the `?`.

## Handling Repetitions 

Sometimes data that we want to match or even remove will have a series of repetitions in it. To handle these cases, we use the curely braces or `{}`. To use this, first put the pattern and then the number of times the repetition occurs. For example, "aaa" would be `a{3}`.

```{r warning=FALSE, message = FALSE}

text = data.frame(
  characters = c("wazup", "wazzup", "wazzzup", "wazzzzup", "naaaada")
)

text%>%
  mutate(match = str_match(characters, "waz{3}up"))

```

You can even specify a range using a comma. 

```{r warning=FALSE, message = FALSE}

text%>%
  mutate(match = str_match(characters, "waz{3,4}up"))

```

As a challenge, what would you need to do to match just the 3rd and 5th rows, "wazzzup" and "naaaada"?

```{r warning=FALSE, message = FALSE}

text%>%
  mutate(match = str_match(characters, ".a.{3}[du]."))

```