---
title: "Regex Explained"
output: html_document
---

A (very) important part of natural language processing is searching for patterns of characters. While this may seem like a somewhat boring part of the process, it is usually the first task in cleaning and preparing data for natural language processing. 

In this tutorial, we will go through how regex is used in R and specifically in the `tidyverse` via the `stringr` package. 

## Pattern Matching with Stringr

`stringr` is the tidyverse solution to working with strings. That means that it plugs in well with packages like `tidytext`, `dplyr` and `tidyr`.

Some stringr functions will return a single vector, which can be turned into a variable using a `mutate` function from the `dplyr` package. In my opinion, these are the most useful functions in `stringr`. They do things like return if a pattern exists, return a pattern itself, or replace a pattern with something new. While `stringr` has more functions, which you can learn more about [here](https://stringr.tidyverse.org), the below four functions make up the backbone of the package. s  

* `str_detect(string, pattern)` detects the presence or absence of a pattern in a string. It will return a TRUE FALSE based on if that pattern is found.
* `str_extract(string, pattern)` extracts text corresponding to the matched pattern
* `str_match(string, pattern)` match text according to a pattern and returns it. Functionally, it is often the same as `str_extract()` but must be used instead of `str_extract()` in specialized instances. 
* `str_replace(string, pattern, replacement)` replaces a matched pattern and returns a character vector.

**These functions all have a variant with an `_all` suffix, which will match all occurrences of a pattern in a string. Without this only the first pattern will be matched**

Lets see how these functions compare when working with data. First we will create a data.frame with a text variable with some sample text.

```{r warning=FALSE, message=FALSE}

library(dplyr)
library(stringr)
library(kableExtra)

sample = data.frame(text = c("this is some sample text",
                    "it is comprised of ample text",
                    "I hope it will help",
                    "if not, than 'oh welp.'",
                    "text only and we in heaven,",
                    "but life is hard so 567."
                    ))

kable(sample)%>%
  kable_styling("striped")
```

Now lets test out `str_detect`, `str_extract`, and `str_replace` with a pattern of "if".

```{r warning=FALSE, message=FALSE}

sample%>%
  mutate(detect = str_detect(text, "if"),
         extract = str_extract(text, "if"),
         replace = str_replace(text, "if", "IF"))%>%
  kable()%>%
  kable_styling("striped")

```


You will notice that each one of these operations matched the "if" in "life". When we get deeper into the regex portion of this lesson, we will go over how to correct for this. 

### The _all suffix

We mentioned earlier that by appending `_all` we will match all instances of the patterns. Let's take a look at what that means in pratice. 

```{r}
all = c("I am repetitive and repetitive")

str_extract_all(all, "repetitive")
```

Unfortunately, this returns a list of the extracted patterns, so it will be a little difficult to work with this inside a dataframe. This is because you are returning multiple things into what in a dataframe would be a single observation. In other words, the string you are inputting into the function has a length of one, but the number of patterns you can return, in this case two, will oftentimes be greater than one. Thus the function returns a list.  

However, if you are looking to replace all matched patterns within a string, what you return will just be the edited string. And thus, `str_replace_all()` will be tidyverse compatible.  

```{r}
all = c("I am repetitive and repetitive")

str_replace_all(all, "repetitive", "very repetitive")
```

## Metacharacters in Regex

So we have gone over how the three main functions of stringr works with basic patterns. The power of regex comes from using special characters or combinations of characters to mean something different than their literal meaning. For example, a period `.` typically signifies the end of a sentence, but in regex, it serves as a stand in for any character. 

Let's see go over a bunch of these special characters in regex. Look at the comment for how the metacharacter works.

```{r}

sample%>%
  mutate(period = str_extract(text, "."), # . stands for anything. It will return the first character
         character = str_extract(text, "\\w"), # \\w stands for any character
         digit = str_extract(text, "\\d"), # \\d stands for any digit
         white_space = str_extract(text, "\\s"))%>% # \\ stands for any whitespace
  kable()%>%
  kable_styling("striped")
  

```

Moving forward, we will refer to characters that only retain their literal meaning as literals. 

### Escaping Special Characters

This naturally leads to the question of how do you match a period. You use the escape character which is a backward slash `\`. This will tell regex to interpret the next character as a "literal". In R, you have to double escape or write: `\\`.

```{r warning=FALSE, message=FALSE}
# if the word flutter wasn't in here 
sample%>%
  mutate(detect = str_detect(text, "\\."),
         extract = str_extract(text, "\\."),
         replace = str_replace(text, "\\.", " :D"))%>%
  kable()%>%
  kable_styling("striped")


```

## Anchors

Oftentimes, where the pattern is in the string will matter. Using the `^` will only match the pattern if it is at the *start* of the string, and `$` will only match the pattern if it is at the *end* of the string. 

```{r warning=FALSE, message = FALSE}

sample%>%
  mutate(start = str_replace(text, "^text", "----"),
         end = str_replace(text, "text$", "----"))%>%
  kable()%>%
  kable_styling("striped")

```

## Groups

Groups allow you to extract patterns from text without extracting the entire pattern. This can be really useful for extracting things like file names or urls. 

Unfortunately, actually pulling out just the information you need is a little more complicated than you would expect. Especially if you want to stay in a tidy framework. 

First lets look at the solution:

```{r warning=FALSE, message = FALSE}

characters = data.frame(
  text = c("file_record_transcript.pdf", "file_07241999.pdf", "testfile_fake.pdf.tmp")
)

characters%>%
  group_by(text)%>%
  mutate(match = unlist(str_match_all(text, "(.*?)\\.pdf$"))[2])%>%
  kable()%>%
  kable_styling("striped")


```

First, notice that we are using `str_match` instead of `str_extract`. This is because `str_extract` does not work with groups. More importantly, note that we had to wrap the `str_match` in an `unlist` function.  

```{r warning=FALSE, message = FALSE}

text = c("file_record_transcript.pdf", "file_07241999.pdf", "testfile_fake.pdf.tmp")

str_match_all(text, "(.*?)\\.pdf$")

```

For groups, `str_match` will return a **list** with both the full pattern matched and the *just* the group matched as well. For our use case, we are just interested in the matched group. So there we go! We just need to `unlist` (in order to take the patterns out of a list) the variable, and we should have what we need right? And since unlist will put the items in a vector, we just need the second item in the vector.

```{r}

characters%>%
  mutate(match = unlist(str_match_all(text, "(.*?)\\.pdf$"))[2])%>%
  kable()%>%
  kable_styling("striped")


```

Whoops! That put everything into one vector and returned the same element, the second element, for every single variable. To fix this, use a `group_by()` ahead of your mutate so that a unique vector, with only two elements, will be created for each unique row. 

If you are confused as to why the same thing was returned repeatedly without a `group_by` check out what the match variable would look like as a vector. 

```{r}

match = unlist(str_match_all(text, "(.*?)\\.pdf$"))
match

```

## Character and Numeric Ranges 

Ranges allow for you to have multiple possible patterns to match against. Ranges are called using brackets `[]`. 

* `[abc]` will be a, b or c.
* `[^abc]` will be neither a nor b nor c (due to the carrot `^`)
* `[a-c]` will be a *through* c.

```{r warning=FALSE, message = FALSE}

characters = data.frame(
  text = c("can", "man", "fan", "ran", "tan")
)

characters %>%
  mutate(match = str_extract(text, "[cmf]an"),
         match = str_match(text, "[^rt]an"),
         match = str_match(text, "[e-r]an")
         )%>%
  kable()%>%
  kable_styling("striped")

```

The same rules will apply for numbers as well as letters. But its important to remember that for regex, numbers are treated the same as characters. So 154 isnt 154 but 1, 5 and 4. 

```{r warning=FALSE, message = FALSE}

numbers = data.frame(
  text = c(10, 4, 22, 35, 1, 0, 300, 199)
)

numbers %>%
  mutate(
        one2nine = str_extract(text, "^[1-9]$"),
        ten2fiftynine = str_extract(text, "^[1-5][0-9]$"),
        one2twentynine = str_extract(text, "^[1-9]$|^[1-2][0-9]$"),
         )%>%
  kable()%>%
  kable_styling("striped")

```



