---
title: "Regex Explained"
output: html_document
---

A (very) important part of natural language processing is searching for patterns of characters. While this may seem like a somewhat boring part of the process, it is usually the first task in cleaning and preparing data for natural language processing. 

In this tutorial, we will go through how regex is used in R and specifically in the `tidyverse` via the `stringr` package. 

## Pattern Matching with Stringr

`stringr` is the tidyverse solution to working with strings.

### Functions that return a vector

Some stringr functions will return a single vector, which can be turned into a variable using a `mutate` function from the `dplyr` package. In my opinion, these are the most useful functions in `stringr`. They do things like return if a pattern exists, return a pattern itself, or replace a pattern with something new.  

* `str_detect(string, pattern)` detects the presence or absence of a pattern in a string. It will return a TRUE FALSE based on if that pattern is found.
* `str_extract(string, pattern)` extracts text corresponding to the matched pattern
* `str_replace(string, pattern, replacement)` replaces a matched pattern and returns a character vector.

**These functions all have a variant with an `_all` suffix, which will match all occurrences of a pattern in a string. Without this only the first pattern will be matched**

Lets see how these functions compare when working with data. First we will create a data.frame with a text variable with some sample text.

```{r}
sample = data.frame(text = c("this is some sample text",
                    "it is comprised of ample text",
                    "I hope it will help",
                    "if not, than 'oh welp.'",
                    "text only and we in heaven,",
                    "but life is hard so 567."
                    ))

kable(sample)%>%
  kable_styling("striped")
```

Now lets test out `str_detect`, `str_extract`, and `str_replace` with a pattern of "if".

```{r}

sample%>%
  mutate(detect = str_detect(text, "if"),
         extract = str_extract(text, "if"),
         replace = str_replace(text, "if", "IF"))%>%
  kable()%>%
  kable_styling("striped")

```


You will notice that each one of these operations matched the "if" in "life". When we get deeper into the regex portion of this lesson, we will go over how to correct for this. 

### The _all suffix

We mentioned earlier that by appending `_all` we will match all instances of the patterns. Let's take a look at what that means in pratice. 

```{r}
all = c("I am repetitive and repetitive")

str_extract_all(all, "repetitive")
```

Unfortunately, this returns a list of the extracted patterns, so it will be a little difficult to work with this inside a dataframe. This is because you are returning multiple things into what in a dataframe would be a single observation. In other words, the string you are inputting into the function has a length of one, but the number of patterns you can return, in this case two, will oftentimes be greater than one. Thus the function returns a list.  

However, if you are looking to replace all matched patterns within a string, what you return will just be the edited string. And thus, `str_replace_all()` will be tidyverse compatible.  

```{r}
all = c("I am repetitive and repetitive")

str_replace_all(all, "repetitive", "very repetitive")
```

## Metacharacters in Regex

So we have gone over how the three main functions of stringr works with basic patterns. The power of regex comes from using special characters or combinations of characters to mean something different than their literal meaning. For example, a period `.` typically signifies the end of a sentence, but in regex, it serves as a stand in for any character. 

Let's see go over a bunch of these special characters in regex. Look at the comment for how the metacharacter works.

```{r}

sample%>%
  mutate(period = str_extract(text, "."), # . stands for anything. It will return the first character
         character = str_extract(text, "\\w"), # \\w stands for any character
         digit = str_extract(text, "\\d"), # \\d stands for any digit
         white_space = str_extract(text, "\\s")) # \\ stands for any whitespace
  
  

```

Moving forward, we will refer to characters that only retain their literal meaning as literals. 

### Escaping Special Characters

This naturally leads to the question of how do you match a period. You use the escape character which is a backward slash `\`. This will tell regex to interpret the next character as a "literal". In R, you have to double escape or write: `\\`.

```{r warning=FALSE, message=FALSE}
# if the word flutter wasn't in here 
sample%>%
  mutate(detect = str_detect(text, "\\."),
         extract = str_extract(text, "\\."),
         replace = str_replace(text, "\\.", " :D"))%>%
  kable()%>%
  kable_styling("striped")


```

## Anchors

Oftentimes, where the pattern is in the string will matter. Using the `^` will only match the pattern if it is at the *start* of the string, and `$` will only match the pattern if it is at the *end* of the string. 

```{r warning=FALSE, message = FALSE}

sample%>%
  mutate(start = str_replace(text, "^text", "----"),
         end = str_replace(text, "text$", "----"))%>%
  kable()%>%
  kable_styling("striped")

```

## Character and Numeric Ranges 

Ranges allow for you to have multiple possible patterns to match against. Ranges are called using brackets `[]`. 

* `[abc]` will be a, b or c.
* `[^abc]` will be neither a nor b nor c (due to the carrot `^`)
* `[a-c]` will be a *through* c.

```{r warning=FALSE, message = FALSE}

characters = data.frame(
  text = c("can", "man", "fan", "ran", "tan")
)

characters %>%
  mutate(match = str_extract(text, "[cmf]an"),
         match = str_match(text, "[^rt]an"),
         match = str_match(text, "[e-r]an")
         )

```

The same rules will apply for numbers as well as letters. But its important to remember that for regex, numbers are treated the same as characters. So 154 isnt 154 but 1, 5 and 4. 

```{r warning=FALSE, message = FALSE}

numbers = data.frame(
  text = c(10, 4, 22, 35, 1, 0)
)

numbers %>%
  mutate(
        one2nine = str_extract(text, "[1-9]$"),
        ten2fifty = str_extract(text, "[1-5][0-9]"),
        one2twentynine = str_extract(text, "^[1-9]$|^[1-2][0-9]$"),
         )

```


## Handling Repetitions 

Sometimes data that we want to match or even remove will have a series of repetitions in it. To handle these cases, we use the curely braces or `{}`. To use this, first put the pattern and then the number of times the repetition occurs. For example, "aaa" would be `a{3}`. You can even specify a range using a comma like `a{3-4}`. 

```{r warning=FALSE, message = FALSE}

text = data.frame(
  characters = c("wazup", "wazzup", "wazzzup", "wazzzzup", "naaaada")
)

text%>%
  mutate(
      reps = str_match(characters, "waz{3}up"),
      rep_range = str_match(characters, "waz{3,4}up")
         )

```
